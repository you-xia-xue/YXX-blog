# 查询
以下内容为AI生成
## 多表查询
要通过 **方法名约定（隐式生成SQL）** 实现多表查询，核心前提是 **实体类已正确定义关联关系**（如 `@OneToMany`、`@ManyToOne`），框架会通过方法名中的「关联属性+目标表属性」自动生成 `JOIN` 语句，无需手动编写 SQL。

以下以 **3 个典型多表关联场景** 为例，完整给出「实体映射层（关联定义）+ Repository 方法名约定 + Service 调用」，覆盖一对一、一对多、多对多场景，直接可复用。  


### 一、场景1：一对一关联（用户 ↔ 身份证）
#### 业务需求：
- 关联关系：1个用户（`User`）对应1个身份证（`IdCard`），`tb_user` 含外键 `id_card_id` 关联 `tb_id_card.id`；  
- 查询需求：通过身份证号查询用户、通过用户名查询身份证信息。  

#### 1. 映射层：实体关联定义（核心）
```java
// 1. 用户实体（主表）
@Data
@Entity
@Table(name = "tb_user")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long userId; // 主键
    private String userName; // 用户名
    private Integer age;

    // 一对一关联身份证：fetch=LAZY（懒加载，提升性能）
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "id_card_id") // 主表外键：tb_user.id_card_id
    private IdCard idCard; // 关联的身份证实体（关键：方法名需通过此属性引用身份证表）
}

// 2. 身份证实体（从表）
@Data
@Entity
@Table(name = "tb_id_card")
public class IdCard {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id; // 主键
    private String cardNo; // 身份证号（唯一）
    private String address; // 地址

    // 双向关联（可选，便于反向查询）：mappedBy声明由User端维护关联
    @OneToOne(mappedBy = "idCard", fetch = FetchType.LAZY)
    private User user; // 关联的用户实体（关键：反向查询需通过此属性）
}
```

#### 2. Repository 层：方法名约定查询（隐式多表 JOIN）
```java
// 1. UserRepository：通过身份证表的属性查询用户
public interface UserRepository extends JpaRepository<User, Long> {
    // 需求：通过身份证号（IdCard.cardNo）查询用户
    // 方法名规则：findBy + 关联属性名（idCard） + 目标表属性名（CardNo）
    Optional<User> findByIdCardCardNo(String cardNo);

    // 需求：通过用户名（User.userName）和身份证地址（IdCard.address）查询用户
    Optional<User> findByUserNameAndIdCardAddress(String userName, String address);
}

// 2. IdCardRepository：通过用户表的属性查询身份证
public interface IdCardRepository extends JpaRepository<IdCard, Long> {
    // 需求：通过用户名（User.userName）查询身份证
    // 方法名规则：findBy + 关联属性名（user） + 目标表属性名（UserName）
    Optional<IdCard> findByUserUserName(String userName);
}
```

#### 3. Service 层：调用示例
```java
@Service
public class OneToOneService {
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private IdCardRepository idCardRepository;

    // 1. 通过身份证号查询用户
    public User getUserByCardNo(String cardNo) {
        return userRepository.findByIdCardCardNo(cardNo)
                .orElseThrow(() -> new RuntimeException("未找到该身份证对应的用户"));
    }

    // 2. 通过用户名查询身份证
    public IdCard getIdCardByUserName(String userName) {
        return idCardRepository.findByUserUserName(userName)
                .orElseThrow(() -> new RuntimeException("未找到该用户的身份证"));
    }
}
```


### 二、场景2：一对多关联（用户 ↔ 订单）
#### 业务需求：
- 关联关系：1个用户（`User`）对应N个订单（`Order`），`tb_order` 含外键 `user_id` 关联 `tb_user.user_id`；
- 查询需求：查询某个用户的所有未支付订单、查询某个用户的金额大于100元的订单（按金额倒序）。

#### 1. 映射层：实体关联定义（核心）
```java
// 1. 用户实体（一的一方）
@Data
@Entity
@Table(name = "tb_user")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long userId;
    private String userName;

    // 一对多关联订单：mappedBy声明由Order端的user属性维护关联
    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
    private List<Order> orders; // 一个用户有多个订单（关联属性）
}

// 2. 订单实体（多的一方）
@Data
@Entity
@Table(name = "tb_order")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long orderId;
    private String orderNo; // 订单号
    private BigDecimal totalAmount; // 订单金额
    private Integer orderStatus; // 订单状态：0=未支付，1=已支付

    // 多对一关联用户（核心：多表查询的关键关联属性）
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id") // 外键：tb_order.user_id
    private User user; // 每个订单归属一个用户
}
```

#### 2. Repository 层：方法名约定查询
```java
// OrderRepository：查询订单（多的一方，通过关联属性user引用用户表）
public interface OrderRepository extends JpaRepository<Order, Long> {
    // 需求1：查询用户ID=?的所有未支付订单（orderStatus=0）
    // 方法名规则：findBy + 关联属性（user） + 目标表属性（UserId） + And + 本表格属性（OrderStatus）
    List<Order> findByUserUserIdAndOrderStatus(Long userId, Integer orderStatus);

    // 需求2：查询用户名=?且订单金额>100元的订单，按金额倒序
    List<Order> findByUserUserNameAndTotalAmountGreaterThanOrderByTotalAmountDesc(
            String userName, BigDecimal minAmount);

    // 需求3：查询用户ID=?的前5条订单（按创建时间倒序）
    List<Order> findTop5ByUserUserIdOrderByCreateTimeDesc(Long userId);
}
```

#### 3. Service 层：调用示例
```java
@Service
public class OneToManyService {
    @Autowired
    private OrderRepository orderRepository;

    // 1. 查询用户ID=1的未支付订单（orderStatus=0）
    public List<Order> getUnpaidOrdersByUserId(Long userId) {
        return orderRepository.findByUserUserIdAndOrderStatus(userId, 0);
    }

    // 2. 查询用户名"张三"且金额>100元的订单（按金额倒序）
    public List<Order> getHighAmountOrdersByUserName(String userName) {
        return orderRepository.findByUserUserNameAndTotalAmountGreaterThanOrderByTotalAmountDesc(
                userName, new BigDecimal("100"));
    }
}
```


### 三、场景3：多对多关联（用户 ↔ 角色）
#### 业务需求：
- 关联关系：1个用户（`User`）有多个角色（`Role`），1个角色对应多个用户，中间表 `tb_user_role` 含 `user_id` 和 `role_id` 双外键；
- 查询需求：查询某个角色名对应的所有用户、查询同时拥有多个角色的用户。

#### 1. 映射层：实体关联定义（核心）
```java
// 1. 用户实体
@Data
@Entity
@Table(name = "tb_user")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long userId;
    private String userName;

    // 多对多关联角色：指定中间表和双外键
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "tb_user_role", // 中间表名
        joinColumns = @JoinColumn(name = "user_id"), // 中间表关联用户表的外键
        inverseJoinColumns = @JoinColumn(name = "role_id") // 中间表关联角色表的外键
    )
    private List<Role> roles; // 一个用户有多个角色（关联属性）
}

// 2. 角色实体
@Data
@Entity
@Table(name = "tb_role")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long roleId;
    private String roleName; // 角色名（如ADMIN、USER）

    // 双向关联（可选）：mappedBy声明由User端的roles属性维护关联
    @ManyToMany(mappedBy = "roles", fetch = FetchType.LAZY)
    private List<User> users; // 一个角色对应多个用户
}
```

#### 2. Repository 层：方法名约定查询
```java
// UserRepository：通过角色表属性查询用户
public interface UserRepository extends JpaRepository<User, Long> {
    // 需求1：查询角色名=?的所有用户
    // 方法名规则：findBy + 关联属性（roles） + 目标表属性（RoleName）
    List<User> findByRolesRoleName(String roleName);

    // 需求2：查询同时拥有"ADMIN"和"USER"两个角色的用户（And连接）
    List<User> findByRolesRoleNameAndRolesRoleName(String roleName1, String roleName2);

    // 需求3：查询拥有角色名包含"ADMIN"的用户（模糊查询）
    List<User> findByRolesRoleNameContaining(String keyword);
}

// RoleRepository：通过用户表属性查询角色
public interface RoleRepository extends JpaRepository<Role, Long> {
    // 需求：查询用户名=?的所有角色
    List<Role> findByUsersUserName(String userName);
}
```

#### 3. Service 层：调用示例
```java
@Service
public class ManyToManyService {
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private RoleRepository roleRepository;

    // 1. 查询所有ADMIN角色的用户
    public List<User> getAdminUsers() {
        return userRepository.findByRolesRoleName("ADMIN");
    }

    // 2. 查询用户名"张三"的所有角色
    public List<Role> getRolesByUserName(String userName) {
        return roleRepository.findByUsersUserName(userName);
    }

    // 3. 查询同时拥有ADMIN和USER角色的用户
    public List<User> getUsersWithTwoRoles() {
        return userRepository.findByRolesRoleNameAndRolesRoleName("ADMIN", "USER");
    }
}
```


### 四、核心规则与注意事项（必看）
#### 1. 方法名约定的多表查询核心规则
- **关联属性是桥梁**：方法名中必须先写「关联属性名」（如 `user`、`roles`、`idCard`），再写「目标表属性名」（如 `UserId`、`RoleName`），拼接规则：`关联属性名 + 目标表属性名`（首字母大写，驼峰命名）；
- 示例拆解：`findByUserUserName` → `User` 是 `Order` 的关联属性，`UserName` 是 `User` 的属性 → 框架自动生成 `JOIN tb_user u ON o.user_id = u.user_id WHERE u.user_name = ?`；
- 条件组合：支持 `And`/`Or`/`GreaterThan` 等关键字（与单表一致），可跨多表组合条件。

#### 2. 避坑关键
- **关联属性名必须正确**：方法名中的关联属性名（如 `user`、`roles`）必须与实体类中定义的关联属性名完全一致（大小写敏感），否则框架无法解析；
- **懒加载处理**：关联查询默认是 `FetchType.LAZY`（懒加载），查询主表时不会加载关联数据，若需直接使用关联数据（如 `user.getOrders()`），需通过 `@EntityGraph` 或 `JOIN FETCH` 强制加载（避免 `LazyInitializationException`）；
- **多对多的中间表**：无需手动定义中间表实体，JPA 会通过 `@JoinTable` 自动维护，方法名中直接通过关联属性（如 `roles`）引用目标表属性即可；
- **方法名长度**：若条件过多（如 3 个以上跨表条件），方法名会冗长（如 `findByUserUserNameAndRolesRoleNameAndOrderTotalAmountGreaterThan`），此时建议改用 `@Query` 注解写 JPQL，可读性更高。


### 总结
通过方法名约定实现多表查询的核心是「**实体关联定义 + 关联属性+目标表属性拼接**」：
1. 先在实体类中用 `@OneToOne`/`@OneToMany`/`@ManyToMany` 定义表关联；
2. Repository 方法名遵循「`findBy + 关联属性名 + 目标表属性名 + 条件关键字`」；
3. 框架自动生成 `JOIN` 语句和查询条件，无需手动写 SQL，开发效率极高。

上述示例覆盖了主流多表场景，映射层和查询方法可直接复制到 Spring Boot 项目中使用（需确保数据库表结构与实体类一致）。

## 动态查询
当你使用 **Spring Data JPA** 且面临「大量参数 + 参数随机为 null」的场景时，核心解决方案是 **`Specification` 动态条件查询**——它能自动忽略 null 参数，仅拼接非空参数对应的查询条件，完美适配“参数不固定、部分为 null”的需求。

以下是完整的实现方案，包含「实体类 → Repository → Service → Controller」全流程，覆盖常见参数类型（字符串、数字、日期）和分页排序，直接可复用。


### 一、核心思路
1. **动态条件拼接**：用 `Specification` 遍历所有参数，仅当参数「非 null + 非空」时，才添加对应的查询条件（如模糊查询、范围查询、等值查询）；
2. **依赖 `JpaSpecificationExecutor`**：Repository 需继承该接口，JPA 会提供动态条件查询的方法（如 `findAll(Specification, Pageable)`）；
3. **自动忽略 null 参数**：通过 `if (参数 != null)` 或 `StringUtils.hasText(字符串参数)` 判断，避免 null 参数导致的无效查询条件；
4. **整合分页排序**：结合 JPA 的 `Pageable`，同时支持动态条件 + 分页 + 排序，满足列表页高频需求。


### 二、完整实现示例
假设你有一个复杂实体 `User`（含 8 个参数，涵盖字符串、数字、日期类型），需支持这些参数的动态查询（参数可能随机为 null）。

#### 1. 实体类示例（User.java）
```java
import jakarta.persistence.*;
import lombok.Data;
import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "tb_user")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long userId;          // 主键（可选查询）
    private String userName;      // 用户名（模糊查询）
    private String email;         // 邮箱（模糊查询）
    private Integer age;          // 年龄（范围查询：minAge ~ maxAge）
    private String phone;         // 手机号（等值查询）
    private Integer gender;       // 性别（0=未知，1=男，2=女，等值查询）
    private LocalDateTime createTime; // 创建时间（区间查询：startTime ~ endTime）
    private Integer status;       // 状态（0=禁用，1=正常，等值查询）
}
```

#### 2. Repository 层：继承 JpaSpecificationExecutor（关键）
Repository 需同时继承 `JpaRepository`（基础 CRUD + 分页）和 `JpaSpecificationExecutor`（动态条件支持），无需定义具体查询方法，框架自动适配。
```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;

// 泛型：实体类（User）+ 主键类型（Long）
public interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {
    // 无需手动定义方法，靠 JpaSpecificationExecutor 提供动态查询能力
}
```

#### 3. Service 层：动态条件拼接（核心逻辑）
在 Service 中通过 `Specification` 遍历所有参数，仅拼接非 null/空的条件，同时支持分页和排序。

```java
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import jakarta.persistence.criteria.Predicate;
import java.util.ArrayList;
import java.util.List;

@Service
public class UserService {
    private final UserRepository userRepository;

    // 构造器注入（推荐，避免 @Autowired 耦合）
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    /**
     * 动态条件查询（支持大量随机 null 参数）+ 分页 + 排序
     * @param queryParam  查询参数封装（含所有可能的查询字段）
     * @param pageNum     当前页码（前端传递，默认 1）
     * @param pageSize    每页条数（默认 10）
     * @return 分页结果（含数据 + 分页元信息）
     */
    public Page<User> queryUserByDynamicParam(UserQueryParam queryParam, Integer pageNum, Integer pageSize) {
        // 1. 处理分页参数（JPA 页码从 0 开始，需 pageNum-1）
        if (pageNum == null) pageNum = 1;
        if (pageSize == null) pageSize = 10;

        // 2. 构建排序规则（按创建时间倒序，可根据前端参数动态调整）
        Sort sort = Sort.by(Sort.Direction.DESC, "createTime");
        Pageable pageable = PageRequest.of(pageNum - 1, pageSize, sort);

        // 3. 动态拼接查询条件（核心：Specification）
        Specification<User> spec = (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>(); // 存储所有非空条件

            // --------------- 1. 字符串参数：模糊查询（非 null + 非空字符串才添加）---------------
            // 用户名模糊查询（like %keyword%）
            if (StringUtils.hasText(queryParam.getUserName())) {
                predicates.add(cb.like(root.get("userName"), "%" + queryParam.getUserName() + "%"));
            }
            // 邮箱模糊查询
            if (StringUtils.hasText(queryParam.getEmail())) {
                predicates.add(cb.like(root.get("email"), "%" + queryParam.getEmail() + "%"));
            }
            // 手机号等值查询（精确匹配）
            if (StringUtils.hasText(queryParam.getPhone())) {
                predicates.add(cb.equal(root.get("phone"), queryParam.getPhone()));
            }

            // --------------- 2. 数字参数：等值/范围查询（非 null 才添加）---------------
            // 年龄范围查询（minAge <= age <= maxAge）
            if (queryParam.getMinAge() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("age"), queryParam.getMinAge()));
            }
            if (queryParam.getMaxAge() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("age"), queryParam.getMaxAge()));
            }
            // 性别等值查询（0=未知，1=男，2=女）
            if (queryParam.getGender() != null) {
                predicates.add(cb.equal(root.get("gender"), queryParam.getGender()));
            }
            // 状态等值查询（0=禁用，1=正常）
            if (queryParam.getStatus() != null) {
                predicates.add(cb.equal(root.get("status"), queryParam.getStatus()));
            }

            // --------------- 3. 日期参数：区间查询（非 null 才添加）---------------
            // 创建时间区间（startTime <= createTime <= endTime）
            if (queryParam.getStartTime() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("createTime"), queryParam.getStartTime()));
            }
            if (queryParam.getEndTime() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("createTime"), queryParam.getEndTime()));
            }

            // --------------- 4. 组合所有条件（默认 AND 关系，可改为 OR）---------------
            return cb.and(predicates.toArray(new Predicate[0]));
        };

        // 4. 执行动态条件 + 分页查询
        return userRepository.findAll(spec, pageable);
    }
}
```

#### 4. 参数封装类（UserQueryParam.java）
将所有查询参数封装为一个 DTO（数据传输对象），避免 Controller 方法参数过多，便于维护。
```java
import lombok.Data;
import java.time.LocalDateTime;

@Data
public class UserQueryParam {
    // 字符串参数
    private String userName;  // 用户名（模糊查询）
    private String email;     // 邮箱（模糊查询）
    private String phone;     // 手机号（精确查询）

    // 数字参数（含范围查询）
    private Integer minAge;   // 最小年龄
    private Integer maxAge;   // 最大年龄
    private Integer gender;   // 性别
    private Integer status;   // 状态

    // 日期参数（区间查询）
    private LocalDateTime startTime; // 开始时间
    private LocalDateTime endTime;   // 结束时间
}
```

#### 5. Controller 层：接收前端参数并调用
```java
import org.springframework.data.domain.Page;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/user")
public class UserController {
    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    /**
     * 动态条件分页查询（支持大量随机 null 参数）
     * 前端请求示例：
     * /user/dynamic?userName=张&minAge=18&status=1&pageNum=1&pageSize=10
     * （参数可随机组合，未传递的参数自动忽略）
     */
    @GetMapping("/dynamic")
    public ResponseEntity<Page<User>> queryUserDynamic(
            // 接收查询参数（UserQueryParam 自动绑定前端参数）
            UserQueryParam queryParam,
            // 分页参数（默认第 1 页，每页 10 条）
            @RequestParam(required = false) Integer pageNum,
            @RequestParam(required = false) Integer pageSize) {
        
        Page<User> userPage = userService.queryUserByDynamicParam(queryParam, pageNum, pageSize);
        return ResponseEntity.ok(userPage);
    }
}
```


### 三、核心逻辑解析
#### 1. 关键组件作用
- **`JpaSpecificationExecutor`**：提供动态条件查询的入口方法（如 `findAll(Specification, Pageable)`），是 JPA 支持动态参数的核心；
- **`Specification`**：函数式接口，通过 `root`（实体属性操作）、`cb`（条件构建器）拼接查询条件；
- **`Predicate` 列表**：存储所有非 null 参数对应的条件，最终通过 `cb.and(...)` 组合为 AND 关系（如需 OR 可改为 `cb.or(...)`）；
- **`StringUtils.hasText(...)`**：判断字符串参数是否“非 null + 非空 + 非空白字符”，避免无效的模糊查询（如 `LIKE '%%'`）。

#### 2. 如何处理不同类型参数
| 参数类型 | 判断条件                  | 查询方式                | 示例代码                                  |
|----------|---------------------------|-------------------------|-------------------------------------------|
| 字符串   | `StringUtils.hasText(xxx)` | 模糊查询（`like`）      | `cb.like(root.get("userName"), "%" + xxx + "%")` |
| 数字     | `xxx != null`             | 等值（`equal`）/ 范围（`>=`/`<=`） | `cb.greaterThanOrEqualTo(root.get("age"), minAge)` |
| 日期     | `xxx != null`             | 区间（`>=`/`<=`）       | `cb.lessThanOrEqualTo(root.get("createTime"), endTime)` |

#### 3. 前端调用示例
前端可根据需求传递任意参数（未传递的参数自动忽略），例如：
- 查询「用户名含“张” + 年龄≥18 + 状态正常」的用户：  
  `GET /user/dynamic?userName=张&minAge=18&status=1&pageNum=1&pageSize=10`
- 查询「邮箱含“@qq.com” + 性别男 + 创建时间≥2024-01-01」的用户：  
  `GET /user/dynamic?email=@qq.com&gender=1&startTime=2024-01-01T00:00:00&pageNum=2&pageSize=20`


### 四、扩展与优化
#### 1. 支持 OR 条件组合
如果部分参数需要 OR 关系（如“用户名含张 或 邮箱含张”），可单独构建 OR 子条件：
```java
// 示例：用户名含张 或 邮箱含张（OR 关系）
if (StringUtils.hasText(queryParam.getKeyword())) {
    Predicate orPredicate = cb.or(
        cb.like(root.get("userName"), "%" + queryParam.getKeyword() + "%"),
        cb.like(root.get("email"), "%" + queryParam.getKeyword() + "%")
    );
    predicates.add(orPredicate);
}
```

#### 2. 动态排序
支持前端传递排序字段和方向（如 `sortField=age&sortDir=asc`），动态构建 `Sort`：
```java
// Controller 接收排序参数
@GetMapping("/dynamic")
public ResponseEntity<Page<User>> queryUserDynamic(
        UserQueryParam queryParam,
        @RequestParam(required = false) Integer pageNum,
        @RequestParam(required = false) Integer pageSize,
        @RequestParam(required = false, defaultValue = "createTime") String sortField,
        @RequestParam(required = false, defaultValue = "DESC") String sortDir) {
    
    // 动态构建排序
    Sort sort = Sort.by(
        Sort.Direction.valueOf(sortDir.toUpperCase()), 
        sortField
    );
    Pageable pageable = PageRequest.of(pageNum - 1, pageSize, sort);
    // ... 后续逻辑不变
}
```

#### 3. 性能优化
- 避免 `SELECT *`：通过 `root.select(...)` 或 `@Query` 只查询需要的字段；
- 懒加载关联属性：如果实体有关联关系（如 `User` 关联 `Order`），默认用 `FetchType.LAZY`，避免关联数据冗余；
- 索引优化：数据库表中给常用查询字段（如 `user_name`、`status`、`createTime`）建立索引，提升查询速度。


### 五、总结
当 JPA 面临「大量参数 + 随机 null」时，**`Specification` 是最优解**，核心优势：
1. 自动忽略 null 参数，仅拼接有效条件；
2. 支持任意参数组合（字符串、数字、日期等）；
3. 无缝整合分页、排序，满足列表页高频需求；
4. 代码可扩展，新增参数时只需添加对应的条件判断，无需修改其他逻辑。

按上述方案实现后，前端可灵活传递查询参数，后端自动适配，无需担心参数为 null 或参数过多的问题。
