# 算数类型
**算数类型是可以通过运算符直接进行计算的类型**
`bool`:[^1]占用1个字节，使用`true和flase`表示。在内存中只有一个有效bit位表示0/1。
`int`: 整数，通常[^2]是4字节，在一些16位系统是2字节，而在64位系统为4字节或8字节（较少）。取值范围为($-2^{31},2^{31}-1)$
`short`：整数，通常只有2个字节
`char`:整数，通常只有1个字节，里面的数值会根据ACII码转换成对应字符
`float`：浮点数，通常是4字节,可以表示$\pm1.175494351×10^{-38},\pm3.402823466×10^{38}$ 。但是精度只有7位有效数字（整数部分+小数部分）
`double`:双精度浮点数通常是8字节，精度为15-16位
`long`:整数，通常[^1]是4字节,在64位系统是16字节
`long int`: 整数，通常是8字节
`long long`:整数，通常是8字节
`long double`:浮点数，扩展双精度浮点数，通常是16字节
``` C
long a =123L;
float b = 1.0f;
long double c = 123.0lf;
```
[^1]: 在C语言中需使用<stdbool.h>库
[^2]: 通常一般指的是主流的编译器实现
---
`unsigned`:无符号符号，使得算术类型符号位加入记数中，无法表示负数，但范围更大：`unsigned int`表示$2^{32}-1$值
`void`:无类型，通常作为返回值使用或作为未知类型指针使用`void*`

# 指针和引用

# 类型转换
C风格的强制转换类型，易导致未定义行为
```C
int C;
(float) C;
int* p = &C;
*(float*)p;//未定义行为
```

`Cpp`风格的提供了不同情况的强类型转换的检测（额外的性能开销），更容易的定位
`dynamic_cast<目标类型>(被转换变量)`动态检测类型是否能成功强制转换，不能转换则返回nullptr。在使用中可以用于检测基类指针能否成功转换不同的派生类
`reinterpret_cast`把类型解释成另一个类型（等同于类型双关）
`static_cast`编译期检测是否能强制转换，更多的检查（不合法的转换会导致编译失败），派生类可被转换成基类（不能是虚基类）
`const_cast`只读变量类型转换成普通变量
## 枚举类型
`enum`：枚举把有序排列的数字以不同的名字表示。通常枚举类型的第一个元素为0，第二个元素在原基础上加1，以此类推。也可以显式为元素赋值
``` Cpp
enum {apple,bear=2,clock};//此处声明了一个无名枚举类型，可以使用括号内部的名字代替0,2,3
enum color{red,yellow,blue};//此处创建了一个叫color枚举类型，
color a=red;//此处声明的a的值只能是枚举类型内的值
//Cpp可以限定作用域以避免变量名冲突
enum class YouWantToDo{I,just,want,to,study};//枚举类
YouWantToDo a= YouWantToDo::I;//需要显式指出
```
# 结构体和类
在`C`中有且仅有结构体(struct)，且内部只能包含变量成员
``` C
struct Ctypes{
int a;
float b;
}
```
在`Cpp`中结构体和类的区别为`struct`默认是`public`公开成员，而`class`默认是私有成员`private`，在继承上`struct`继承基类为公开成员，`class`则是私有成员。以下内容注要以`class`讲述

在Cpp中类/结构体包含不同的数据类型，函数，通过类可以声明并创建实例，可以对实例进行类的相关操作
1. `public`（公开）修饰类成员可以让类内部的变量/函数可以被外部直接调用
2. 使用`private`（私有）修饰类成员让其只能被内部调用且不可被继承
3. 使用`protected`（保护）修饰类成员，会使得该类成员私有且可以被继承调用
4. 含有纯虚函数的类为抽象类(不能建立实例)
	不含纯虚函数的类为具体类(不能建立实例)
5. 在类内声明*friend*类（友元），可以使得该友元类使用该类的所有成员。如果用声明一个友元函数，则函数可以调用该类的所有成员（无需通过公共接口）

|      结构体       |       类        |
| :------------: | :------------: |
|   数据类型组成的结构    |  功能和不同类型组成的结构  |
| 默认公有（`public`） | 默认私有`private`  |
| 继承默认为`pubilc`  | 继承默认为`private` |
结构体/类定义的变量称为成员变量(`member`)
同理也有成员函数
可以用不同的命名方式作为提示（比如m_)
可以使用：：(作用域运算符)指定类的成员
可以对成员函数用const修饰以实现调用只读类成员
如果成员用mutable修饰，则在const 成员函数内也可以对该成员进行修改
``` Cpp
class A{
private:
int m_x,m_y;
public:
	void GetX() const{
	//m_x只读
		std::cout<< m_x;
	}
	//第一个const描述一个不可被修改的int变量，第二个描述不可修改的int指针，第三个描述调用的类成员不可被修改
	const int* const SetX() const{}
}
```

我们可以在构造函数这样定义实现成员的初始化(避免在构造函数内进行调用赋值导致的性能开销)
``` Cpp
class test{
private:
	int someone,asd;
public:
//冒号位置在函数声明后方
	test(int X)
	:someone(X),asd(8);//成员带括号，括号内赋值
	{
	}	
}
```

实例内每一个非静态成员函数调用时，本质上向函数传递了实例本身，所以可以在函数内调用实例的成员变量
![[Pasted image 20250824154001.png]]
### this
使用this关键字可以获取指向当前类的指针（不可以被修改的指针常量）
以确保在相同变量名的情况下能正确调用当前实例的成员
``` Cpp
class test{
public:
	int x, y;
	test(int x,int y){
		this->x = x;
		this->y = y
		test* const e = this;
		test& f = *this;
	}
	test()const{
		const test* const e = this;
		const test& f = this
	}
}
```
### 单例(singleton) 设计模式
[教学视频](https://www.bilibili.com/video/BV1Dk4y1j7oj/?p=83&share_source=copy_web&vd_source=db8aceb651e9de7c3673c5eee54d917f)
一个类在全局中只有一个实例，则为单例。
使用`::`（作用域运算符）调用类的静态方法来调用实例并对其操作
例
``` Cpp
class singleton{
public:
singleton(const singleton&)=delete;//删除复制构造函数
 //类的静态方法，返回实例的引用.可以直接通过方法调用其他方法
 static singleton& Get(){
 //因为static修饰的变量在静态内存中，所以不用创建变量通过该方法在静态内存中调用即可
	 static singleton Instance;
	 return Instance;
 }
private:
singleton(){}=delete;//可以删掉构造函数避免被创建其他实例
}
```
`singleton::get().function`这样调用实例的方法
`auto& a = singlenton::get()`创建单例的引用
使用[[#命名空间(namespace)]]可以达到类似的效果，只是不能创建引用。 

### 构造函数
构造函数是创建实例时对实例进行的操作
如果使用下面的代码将无法创建实例
``` C++
//删除默认的函数
log()=delete;
```
在类中用类名定义一个构造函数使创建实例时，会使用该函数初始化实例或者其他操作
![[Pasted image 20250825092131.png]]
这里e使用了类的构建函数，并初始化了成员变量
``` Cpp
Entity e(10.f,5.f)
```
#### 拷贝构造函数
Cpp默认提供了一个拷贝构造函数以实现实例之间的赋值
但是会出现复制指针导致的多指针指向同一块内存的情况出现（浅拷贝）。
如果要避免该问题需要深拷贝：分配并复制内存，指针指向新的内存以避免重复释放
``` Cpp
class String{
int* x,y;
public:
//默认构造函数原理
	String(){};
//默认拷贝构造函数原理
	/*String(const String &other):x(other.x),y(other.y){}*/
//深拷贝
	String(const String &other):y(other.y){
	x = new int;
	memcpy(x,other.x,sizeof(int))
	}
}
```
尽量使用`const`+引用调用函数以避免重复创建实例
### 析构函数
当一个实例被销毁时（无论是栈实例，还是堆实例），会使用这个函数。在实例的生命周期结束时，实例都会调用析构函数再销毁
``` Cpp
class Notclass{
~test(){}}
```
也可以通过实例调用析构函数（不会销毁实例）
#### 虚析构函数
多态使用基类指针销毁时只会调用基类的析构函数，使用`virtual`使得析构函数称为虚函数，和普通虚函数相同，不同的是：
1. 基类必须提供实现
2. 派生类的析构函数自动变成虚函数（可以省略`virtual`）
### 继承
[学习视频](https://www.bilibili.com/video/BV1Dk4y1j7oj/?p=28&share_source=copy_web&vd_source=db8aceb651e9de7c3673c5eee54d917f&t=410)
一个类可以继承其他类（基类），使得基类（派生类）可以得到派生类的公开(public)和保护(protected)的功能（默认继承为类的私有成员）
结构体类似原理（不过默认继承为公开成员）
派生类总是基类的超集，派生类可以在基类的基础上实现不同的功能
``` Cpp
class father{
public:
int a,b
}
//下面继承father类的成员为公开成员
class child : pubilc father{}
//child的实例可以调用a,b
class child1 : pubilc father,pubilc child2{}
//多继承
```
**创建派生类会调用基类的构造函数，析构同理**
如果派生类定义了和基类同名的成员，那么会隐藏基类的同名成员，派生类调用需指出：
\[基类名]：\[成员]
如果外部函数使用了基类指针作为参数，那么也可以取派生类的地址作为参数
这样调用时，如果派生类和基类有同名函数，只能使用基类定义的同名函数（可能不符合预期），如果想使用派生类的同名函数实现需要使用虚函数。

#### 虚函数（virtual funcion）
派生类继承基类的函数时，只能调用基类方法的实现，虚函数可以让派生类覆写基类的函数

虚函数的核心是实现对派生类中继承的基类成员的覆写。
基类负责提供通用的功能（描述基本功能），派生类可以选择覆写(可以用override特指)这一接口使该方法与自身绑定，绑定后编译会在调用（可以用基类指针/引用调用）该类方法会自动匹配该类
覆写要求:
1. 返回类型一致（如果返回派生类则可以不同）
2. 参数一致
3. 函数名一致
下面是定义在类的动态实现
``` Cpp
class X {
public:
	virtual void say(){//虚函数
	 std::cout<<"test"<<std::endl;
	}
}
class X1 : public X{
	void say() override {//覆写函数
	std::cout<<"test"<<std::endl;
	}
}
```
也可以在类外定义不同的重载函数作为静态实现

虚函数会造成性能开销：
	 需要内存建立V表以映射不同的类型到对应的函数内
	 调用时需要遍历V表以确定使用的函数
	 需要指针指向V表
#### 接口（interface）（纯虚函数）
这样定义一个虚函数:
``` Cpp
virtual void test()=0;
```
这表明该成员方法没有实现，该类的派生类必须要实现该函数（覆写）才能构建实例
**使用纯虚函数的类不能建立一个实例**
从需求上看纯虚函数给派生类提供了一个需要被实现的方法，指导派生类需要实现什么
### 封装
通过控制类的访问权限，实现隐藏必要的操作，同时开放对外的接口。实现保护数据同时隐藏类内部的操作。
1. 数据安全
2. 降低耦合
3. 简化使用
4. 代码可控

### 多态
通过指向派生类的基类指针，调用基类的虚函数接口，使用派生类的函数实现
**一个接口多个实现**
不过本质是根据实例类型取调用对应类的方法

可以写一个仅使用基类指针作为参数的通用函数来处理所有的派生对象
优点
1. 接口与实现分离（基类接口，派生类实现）
2. 扩展性强（派生类只覆写，不改调用）
3. 代码更简洁且通用
### 静态（static）
**如果只论在结构体和类外的静态变量或函数**，和C的功能是一样的（调整生命周期，内部链接属性）
1. 在编译时就初始化并创建在程序中（只初始化一次） 
2. 功能上类似于文件范围内的“private”
3. 可以解决不同翻译单元名字冲突的问题
4. 作用域则为对应的函数内（在函数内才能被调用）
可以使"s_"作为提示

**使用static在结构体和类中修饰变量/函数会使其丧失类的特性（变量本身先于实例产生）**

---
**结构体和类使用static修饰变量**
编译时就会为结构体/类建立实例通用的静态变量
结构体/类创建实例的共用同一个静态变量。
虽然可以通过实例操纵变量，但本质上是对“类”的修改
所以可以使用：
\[结构名/类名]::\[变量名]对类的静态变量进行修改

**结构体和类使用static修饰函数**
编译时就会为结构体/类建立一个通用的静态方法
静态函数同理\[结构名/类名]::\[方法名]进行调用
但是静态函数不能调用非静态变量：因为静态函数先于实例存在。
若调用了一个非静态变量
从逻辑上讲：编译器不知道要调用哪一个实例的变量。
从本质上，函数调用时没有传入实例，但是调用了一个未知的实例的成员变量
所以出现了语法错误
# 联合体（union）
`union`使得同一块内存可以用不同类型表示（大小取决于最大的）
 通常通过结构体间接使用
 
``` Cpp
struct Union{
 union{
 int a;
 float b;
 }
}
Union.a=4;
Union.b;

```
以下方法实现了一个内存同时表示两种类型
![[Pasted image 20250830191049.png]]
