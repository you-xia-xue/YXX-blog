# 多表查询
以下内容为AI生成   
要通过 **方法名约定（隐式生成SQL）** 实现多表查询，核心前提是 **实体类已正确定义关联关系**（如 `@OneToMany`、`@ManyToOne`），框架会通过方法名中的「关联属性+目标表属性」自动生成 `JOIN` 语句，无需手动编写 SQL。

以下以 **3 个典型多表关联场景** 为例，完整给出「实体映射层（关联定义）+ Repository 方法名约定 + Service 调用」，覆盖一对一、一对多、多对多场景，直接可复用。  


### 一、场景1：一对一关联（用户 ↔ 身份证）
#### 业务需求：
- 关联关系：1个用户（`User`）对应1个身份证（`IdCard`），`tb_user` 含外键 `id_card_id` 关联 `tb_id_card.id`；  
- 查询需求：通过身份证号查询用户、通过用户名查询身份证信息。  

#### 1. 映射层：实体关联定义（核心）
```java
// 1. 用户实体（主表）
@Data
@Entity
@Table(name = "tb_user")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long userId; // 主键
    private String userName; // 用户名
    private Integer age;

    // 一对一关联身份证：fetch=LAZY（懒加载，提升性能）
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "id_card_id") // 主表外键：tb_user.id_card_id
    private IdCard idCard; // 关联的身份证实体（关键：方法名需通过此属性引用身份证表）
}

// 2. 身份证实体（从表）
@Data
@Entity
@Table(name = "tb_id_card")
public class IdCard {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id; // 主键
    private String cardNo; // 身份证号（唯一）
    private String address; // 地址

    // 双向关联（可选，便于反向查询）：mappedBy声明由User端维护关联
    @OneToOne(mappedBy = "idCard", fetch = FetchType.LAZY)
    private User user; // 关联的用户实体（关键：反向查询需通过此属性）
}
```

#### 2. Repository 层：方法名约定查询（隐式多表 JOIN）
```java
// 1. UserRepository：通过身份证表的属性查询用户
public interface UserRepository extends JpaRepository<User, Long> {
    // 需求：通过身份证号（IdCard.cardNo）查询用户
    // 方法名规则：findBy + 关联属性名（idCard） + 目标表属性名（CardNo）
    Optional<User> findByIdCardCardNo(String cardNo);

    // 需求：通过用户名（User.userName）和身份证地址（IdCard.address）查询用户
    Optional<User> findByUserNameAndIdCardAddress(String userName, String address);
}

// 2. IdCardRepository：通过用户表的属性查询身份证
public interface IdCardRepository extends JpaRepository<IdCard, Long> {
    // 需求：通过用户名（User.userName）查询身份证
    // 方法名规则：findBy + 关联属性名（user） + 目标表属性名（UserName）
    Optional<IdCard> findByUserUserName(String userName);
}
```

#### 3. Service 层：调用示例
```java
@Service
public class OneToOneService {
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private IdCardRepository idCardRepository;

    // 1. 通过身份证号查询用户
    public User getUserByCardNo(String cardNo) {
        return userRepository.findByIdCardCardNo(cardNo)
                .orElseThrow(() -> new RuntimeException("未找到该身份证对应的用户"));
    }

    // 2. 通过用户名查询身份证
    public IdCard getIdCardByUserName(String userName) {
        return idCardRepository.findByUserUserName(userName)
                .orElseThrow(() -> new RuntimeException("未找到该用户的身份证"));
    }
}
```


### 二、场景2：一对多关联（用户 ↔ 订单）
#### 业务需求：
- 关联关系：1个用户（`User`）对应N个订单（`Order`），`tb_order` 含外键 `user_id` 关联 `tb_user.user_id`；
- 查询需求：查询某个用户的所有未支付订单、查询某个用户的金额大于100元的订单（按金额倒序）。

#### 1. 映射层：实体关联定义（核心）
```java
// 1. 用户实体（一的一方）
@Data
@Entity
@Table(name = "tb_user")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long userId;
    private String userName;

    // 一对多关联订单：mappedBy声明由Order端的user属性维护关联
    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
    private List<Order> orders; // 一个用户有多个订单（关联属性）
}

// 2. 订单实体（多的一方）
@Data
@Entity
@Table(name = "tb_order")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long orderId;
    private String orderNo; // 订单号
    private BigDecimal totalAmount; // 订单金额
    private Integer orderStatus; // 订单状态：0=未支付，1=已支付

    // 多对一关联用户（核心：多表查询的关键关联属性）
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id") // 外键：tb_order.user_id
    private User user; // 每个订单归属一个用户
}
```

#### 2. Repository 层：方法名约定查询
```java
// OrderRepository：查询订单（多的一方，通过关联属性user引用用户表）
public interface OrderRepository extends JpaRepository<Order, Long> {
    // 需求1：查询用户ID=?的所有未支付订单（orderStatus=0）
    // 方法名规则：findBy + 关联属性（user） + 目标表属性（UserId） + And + 本表格属性（OrderStatus）
    List<Order> findByUserUserIdAndOrderStatus(Long userId, Integer orderStatus);

    // 需求2：查询用户名=?且订单金额>100元的订单，按金额倒序
    List<Order> findByUserUserNameAndTotalAmountGreaterThanOrderByTotalAmountDesc(
            String userName, BigDecimal minAmount);

    // 需求3：查询用户ID=?的前5条订单（按创建时间倒序）
    List<Order> findTop5ByUserUserIdOrderByCreateTimeDesc(Long userId);
}
```

#### 3. Service 层：调用示例
```java
@Service
public class OneToManyService {
    @Autowired
    private OrderRepository orderRepository;

    // 1. 查询用户ID=1的未支付订单（orderStatus=0）
    public List<Order> getUnpaidOrdersByUserId(Long userId) {
        return orderRepository.findByUserUserIdAndOrderStatus(userId, 0);
    }

    // 2. 查询用户名"张三"且金额>100元的订单（按金额倒序）
    public List<Order> getHighAmountOrdersByUserName(String userName) {
        return orderRepository.findByUserUserNameAndTotalAmountGreaterThanOrderByTotalAmountDesc(
                userName, new BigDecimal("100"));
    }
}
```


### 三、场景3：多对多关联（用户 ↔ 角色）
#### 业务需求：
- 关联关系：1个用户（`User`）有多个角色（`Role`），1个角色对应多个用户，中间表 `tb_user_role` 含 `user_id` 和 `role_id` 双外键；
- 查询需求：查询某个角色名对应的所有用户、查询同时拥有多个角色的用户。

#### 1. 映射层：实体关联定义（核心）
```java
// 1. 用户实体
@Data
@Entity
@Table(name = "tb_user")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long userId;
    private String userName;

    // 多对多关联角色：指定中间表和双外键
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "tb_user_role", // 中间表名
        joinColumns = @JoinColumn(name = "user_id"), // 中间表关联用户表的外键
        inverseJoinColumns = @JoinColumn(name = "role_id") // 中间表关联角色表的外键
    )
    private List<Role> roles; // 一个用户有多个角色（关联属性）
}

// 2. 角色实体
@Data
@Entity
@Table(name = "tb_role")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long roleId;
    private String roleName; // 角色名（如ADMIN、USER）

    // 双向关联（可选）：mappedBy声明由User端的roles属性维护关联
    @ManyToMany(mappedBy = "roles", fetch = FetchType.LAZY)
    private List<User> users; // 一个角色对应多个用户
}
```

#### 2. Repository 层：方法名约定查询
```java
// UserRepository：通过角色表属性查询用户
public interface UserRepository extends JpaRepository<User, Long> {
    // 需求1：查询角色名=?的所有用户
    // 方法名规则：findBy + 关联属性（roles） + 目标表属性（RoleName）
    List<User> findByRolesRoleName(String roleName);

    // 需求2：查询同时拥有"ADMIN"和"USER"两个角色的用户（And连接）
    List<User> findByRolesRoleNameAndRolesRoleName(String roleName1, String roleName2);

    // 需求3：查询拥有角色名包含"ADMIN"的用户（模糊查询）
    List<User> findByRolesRoleNameContaining(String keyword);
}

// RoleRepository：通过用户表属性查询角色
public interface RoleRepository extends JpaRepository<Role, Long> {
    // 需求：查询用户名=?的所有角色
    List<Role> findByUsersUserName(String userName);
}
```

#### 3. Service 层：调用示例
```java
@Service
public class ManyToManyService {
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private RoleRepository roleRepository;

    // 1. 查询所有ADMIN角色的用户
    public List<User> getAdminUsers() {
        return userRepository.findByRolesRoleName("ADMIN");
    }

    // 2. 查询用户名"张三"的所有角色
    public List<Role> getRolesByUserName(String userName) {
        return roleRepository.findByUsersUserName(userName);
    }

    // 3. 查询同时拥有ADMIN和USER角色的用户
    public List<User> getUsersWithTwoRoles() {
        return userRepository.findByRolesRoleNameAndRolesRoleName("ADMIN", "USER");
    }
}
```


### 四、核心规则与注意事项（必看）
#### 1. 方法名约定的多表查询核心规则
- **关联属性是桥梁**：方法名中必须先写「关联属性名」（如 `user`、`roles`、`idCard`），再写「目标表属性名」（如 `UserId`、`RoleName`），拼接规则：`关联属性名 + 目标表属性名`（首字母大写，驼峰命名）；
- 示例拆解：`findByUserUserName` → `User` 是 `Order` 的关联属性，`UserName` 是 `User` 的属性 → 框架自动生成 `JOIN tb_user u ON o.user_id = u.user_id WHERE u.user_name = ?`；
- 条件组合：支持 `And`/`Or`/`GreaterThan` 等关键字（与单表一致），可跨多表组合条件。

#### 2. 避坑关键
- **关联属性名必须正确**：方法名中的关联属性名（如 `user`、`roles`）必须与实体类中定义的关联属性名完全一致（大小写敏感），否则框架无法解析；
- **懒加载处理**：关联查询默认是 `FetchType.LAZY`（懒加载），查询主表时不会加载关联数据，若需直接使用关联数据（如 `user.getOrders()`），需通过 `@EntityGraph` 或 `JOIN FETCH` 强制加载（避免 `LazyInitializationException`）；
- **多对多的中间表**：无需手动定义中间表实体，JPA 会通过 `@JoinTable` 自动维护，方法名中直接通过关联属性（如 `roles`）引用目标表属性即可；
- **方法名长度**：若条件过多（如 3 个以上跨表条件），方法名会冗长（如 `findByUserUserNameAndRolesRoleNameAndOrderTotalAmountGreaterThan`），此时建议改用 `@Query` 注解写 JPQL，可读性更高。


### 总结
通过方法名约定实现多表查询的核心是「**实体关联定义 + 关联属性+目标表属性拼接**」：
1. 先在实体类中用 `@OneToOne`/`@OneToMany`/`@ManyToMany` 定义表关联；
2. Repository 方法名遵循「`findBy + 关联属性名 + 目标表属性名 + 条件关键字`」；
3. 框架自动生成 `JOIN` 语句和查询条件，无需手动写 SQL，开发效率极高。

上述示例覆盖了主流多表场景，映射层和查询方法可直接复制到 Spring Boot 项目中使用（需确保数据库表结构与实体类一致）。